# 동기/비동기 컨텍스트 성능 비교 분석 리포트

**테스트 일시**: 2026-01-13
**테스트 설정**: Users=100, Spawn Rate=10, Run Time=2분
**테스트 환경**: macOS Darwin 24.6.0, Docker

---

## 1. 테스트 환경 구성

| 케이스 | 인스턴스 수 | 워커 수/인스턴스 | 총 워커 | 구성 |
|--------|------------|-----------------|---------|------|
| single_w1 | 1 | 1 | **1** | 단일 앱 |
| single_w4 | 1 | 4 | **4** | 단일 앱 |
| multi_w1 | 3 | 1 | **3** | Nginx + 3 앱 |
| multi_w4 | 3 | 4 | **12** | Nginx + 3 앱 |

---

## 2. ASGI에서 동기 함수 처리 방식

### 2.1 Starlette/FastAPI 내부 동작

```python
# Starlette 내부 구현 (개념)
async def run_endpoint(func, *args, **kwargs):
    if asyncio.iscoroutinefunction(func):
        # async def: 이벤트 루프에서 직접 실행
        return await func(*args, **kwargs)
    else:
        # def: ThreadPoolExecutor에서 실행
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, func, *args, **kwargs)
```

### 2.2 ThreadPoolExecutor 특성

- **기본 스레드 풀 크기**: `min(32, os.cpu_count() + 4)` ≈ 8개
- 동시 요청이 스레드 풀 크기를 초과하면 대기 발생
- I/O 대기 중에도 스레드를 점유 → 병목 발생

### 2.3 예상 vs 실제

| 항목 | 예상 | 실제 결과 |
|------|------|----------|
| 단순 응답 | 동기/비동기 차이 없음 | **20-80% 차이** (동기가 느림) |
| I/O 바운드 | 차이 없음 | **극적인 차이** (동기는 블로킹) |

**결론**: ASGI의 동기 처리는 "이벤트 루프 블로킹 방지"일 뿐, "동등한 성능"을 의미하지 않음

---

## 3. Simple Response Test 결과 (단순 응답)

### 3.1 결과 요약

| 케이스 | 총 워커 | RPS | 평균 (ms) | 중앙값 (ms) | 95% (ms) | 실패율 |
|--------|---------|-----|-----------|-------------|----------|--------|
| single_w1 | 1 | 310.0 | 10.3 | 7 | 26 | 0% |
| single_w4 | 4 | 310.6 | 7.7 | 6 | 16 | 0% |
| **multi_w1** | 3 | **314.6** | **6.5** | **5** | **12** | 0% |
| multi_w4 | 12 | 305.0 | 15.9 | 7 | 50 | **6%** |

### 3.2 동기 vs 비동기 세부 비교

| 케이스 | ASYNC 평균 | SYNC 평균 | 차이 |
|--------|-----------|-----------|------|
| single_w1 | 7.4ms | 13.5ms | **+82%** |
| single_w4 | 6.9ms | 8.4ms | **+22%** |
| multi_w1 | 5.8ms | 7.3ms | **+26%** |
| multi_w4 | 15.0ms | 16.6ms | +11% |

### 3.3 분석

```
┌────────────────────────────────────────────────────────────────────┐
│              Simple Response - RPS 비교                            │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  single_w1 (1)   ████████████████████████████████ 310 RPS         │
│  single_w4 (4)   ████████████████████████████████ 311 RPS         │
│  multi_w1  (3)   █████████████████████████████████ 315 RPS  ★     │
│  multi_w4  (12)  ███████████████████████████████ 305 RPS (6% 실패)│
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

**핵심 발견**:
1. **단순 응답에서 워커/인스턴스 증가 효과 제한적** - RPS 거의 동일
2. **multi_w4에서 실패 발생** - 리소스 경쟁으로 인한 오버헤드
3. **multi_w1이 가장 효율적** - 낮은 지연시간, 0% 실패

---

## 4. I/O Wait Test 결과 (I/O 대기)

### 4.1 결과 요약

| 케이스 | 총 워커 | RPS | 평균 (ms) | 중앙값 (ms) | 실패율 |
|--------|---------|-----|-----------|-------------|--------|
| single_w1 | 1 | 2.18 | 19,357 | 21,000 | **23.8%** |
| single_w4 | 4 | 9.14 | 4,791 | 3,800 | 0% |
| multi_w1 | 3 | 7.34 | 6,050 | 4,900 | 0% |
| **multi_w4** | 12 | **22.30** | **1,827** | **1,600** | 0% |

### 4.2 동기 vs 비동기 세부 비교 (I/O 1초 대기)

| 케이스 | ASYNC 1s | SYNC 1s | 차이 |
|--------|----------|---------|------|
| single_w1 | 23.6s (76% 실패) | 28.9s (94% 실패) | SYNC 거의 불가 |
| single_w4 | 5.6s | 8.8s | **+57%** |
| multi_w1 | 6.8s | 10.0s | **+47%** |
| multi_w4 | 1.7s | 1.9s | +12% |

### 4.3 분석

```
┌────────────────────────────────────────────────────────────────────┐
│              I/O Wait - RPS 비교 (극적인 차이!)                     │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  single_w1 (1)   ██ 2.2 RPS (24% 실패)                             │
│  single_w4 (4)   █████████ 9.1 RPS                                 │
│  multi_w1  (3)   ███████ 7.3 RPS                                   │
│  multi_w4  (12)  ██████████████████████ 22.3 RPS  ★ 최고 성능      │
│                                                                    │
│  성능 향상: single_w1 → multi_w4 = 10배 ↑                          │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

**핵심 발견**:
1. **I/O 바운드에서 워커/인스턴스 증가 효과 극대화**
2. **single_w1은 사실상 사용 불가** - 94% 실패
3. **multi_w4가 압도적** - RPS 10배, 응답시간 90% 감소

---

## 5. 종합 비교

### 5.1 워크로드별 최적 구성

| 워크로드 | 최적 구성 | RPS | 평균 응답 | 비고 |
|----------|----------|-----|----------|------|
| **단순 응답** | multi_w1 | 315 | 6.5ms | 낮은 오버헤드 |
| **I/O 바운드** | multi_w4 | 22.3 | 1.8s | 최대 병렬 처리 |
| **혼합** | multi_w4 또는 single_w4 | - | - | 상황에 따라 |

### 5.2 스케일링 효과

```
┌────────────────────────────────────────────────────────────────────┐
│                    스케일링 효과 비교                               │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  [단순 응답]                                                       │
│  워커 1→4:  RPS +0%,  응답시간 -25%                                │
│  인스턴스 1→3: RPS +1%,  응답시간 -37%                             │
│                                                                    │
│  [I/O 바운드]                                                      │
│  워커 1→4:  RPS +320%, 응답시간 -75%  ★                            │
│  인스턴스 1→3: RPS +237%, 응답시간 -69%  ★                         │
│  전체 (1→12): RPS +923%, 응답시간 -91%  ★★★                       │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## 6. 결론 및 권장사항

### 6.1 핵심 교훈

1. **ASGI 동기 처리 ≠ 동등한 성능**
   - ThreadPoolExecutor 오버헤드로 인해 동기 함수가 20-80% 느림
   - I/O 바운드에서는 동기 함수가 스레드를 블로킹하여 병목 발생

2. **워크로드에 따른 스케일링 효과 차이**
   - 단순 응답: 스케일링 효과 미미 (이미 충분히 빠름)
   - I/O 바운드: 스케일링 효과 극대화 (10배 이상 개선 가능)

3. **과도한 리소스는 오히려 역효과**
   - multi_w4 (12워커)는 단순 응답에서 6% 실패 발생
   - 리소스 경쟁, 컨텍스트 스위칭 오버헤드

### 6.2 환경별 권장 설정

| 상황 | 권장 구성 | 이유 |
|------|----------|------|
| **API 서버 (단순 CRUD)** | single_w4 또는 multi_w1 | 낮은 지연시간, 안정성 |
| **I/O 집약 (외부 API, DB)** | multi_w4 | 최대 동시 처리 |
| **리소스 제한 환경** | single_w1 + 비동기 필수 | 최소 리소스로 최대 효율 |
| **고가용성 필요** | multi_w1 이상 | 인스턴스 장애 대비 |

### 6.3 코드 레벨 권장사항

```python
# BAD: I/O 작업에 동기 함수 사용
@app.get("/bad")
def bad_endpoint():
    time.sleep(1)  # 스레드 블로킹!
    return {"status": "bad"}

# GOOD: I/O 작업에 비동기 함수 사용
@app.get("/good")
async def good_endpoint():
    await asyncio.sleep(1)  # 이벤트 루프 양보
    return {"status": "good"}

# GOOD: DB 작업도 비동기로
@app.get("/db")
async def db_endpoint(session: AsyncSession = Depends(get_async_session)):
    result = await session.execute(query)  # 비동기 DB 드라이버 사용
    return result
```

---

## 7. 참고 데이터

### 테스트 결과 디렉토리

- Single 인스턴스: `comparison_20260113_211808/single_w1`, `single_w4`
- Multi 인스턴스: `multi_20260113_213949/multi_w1`, `multi_w4`

### 테스트 도구

- **Locust**: 부하 테스트
- **Docker Compose**: 환경 구성
- **Nginx**: 로드밸런서 (multi 인스턴스)
- **PostgreSQL**: 데이터베이스
- **Uvicorn**: ASGI 서버

---

*Generated: 2026-01-13*
